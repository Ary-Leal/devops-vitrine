1. Aplica√ß√£o Web ‚Äì Node.js com Express

1. Importa√ß√£o do m√≥dulo express
Copiar
const express = require('express');
Esse c√≥digo importa o m√≥dulo express, que √© um framework popular para criar aplica√ß√µes web e APIs em Node.js.
O express fornece funcionalidades para lidar com rotas, requisi√ß√µes HTTP, respostas e muito mais.
2. Cria√ß√£o da aplica√ß√£o Express
Copiar
const app = express();
Aqui, criamos uma inst√¢ncia do Express chamada app. Essa inst√¢ncia ser√° usada para definir rotas e configurar o servidor.
3. Defini√ß√£o da porta
Copiar
const port = process.env.PORT || 3000;
A constante port define a porta na qual o servidor ir√° rodar.
process.env.PORT verifica se h√° uma vari√°vel de ambiente chamada PORT definida (isso √© √∫til em ambientes de produ√ß√£o, como servidores na nuvem).
Caso n√£o exista uma vari√°vel de ambiente, o servidor usar√° a porta padr√£o 3000.
4. Defini√ß√£o de uma rota /health
Copiar
app.get('/health', (req, res) => {
  res.status(200).send('OK');
});
Esse trecho define uma rota HTTP do tipo GET que responde ao caminho /health.
Quando um cliente (como um navegador ou um servi√ßo externo) faz uma requisi√ß√£o para /health, o servidor responde com:
Um status HTTP 200, que indica que a requisi√ß√£o foi bem-sucedida.
A mensagem "OK" como corpo da resposta.
Essa rota √© comumente usada para verificar se o servidor est√° funcionando corretamente. √â conhecida como "rota de sa√∫de" ou "health check".

5. Inicializa√ß√£o do servidor
Copiar
app.listen(port, () => {
  console.log(`Servidor rodando na porta ${port}`);
});
O m√©todo app.listen() inicia o servidor na porta especificada em port.
Quando o servidor come√ßa a rodar, ele executa o callback fornecido (a fun√ß√£o dentro do listen), que imprime no console:
Servidor rodando na porta ${port} Isso √© √∫til para saber que o servidor est√° ativo e em qual porta ele est√° escutando.
Resumo do funcionamento completo:
O c√≥digo configura um servidor HTTP usando o framework Express.
Define uma rota /health, que pode ser acessada para verificar se o servidor est√° funcionando.
Inicia o servidor na porta especificada (por padr√£o, 3000) e exibe uma mensagem no console indicando que tudo est√° funcionando.
Exemplo de uso:
Se voc√™ rodar esse c√≥digo e acessar no navegador ou via ferramentas como curl:

Copiar
http://localhost:3000/health
Voc√™ ver√° a resposta:

Copiar
OK
Isso indica que o servidor est√° funcionando corretamente

2. Docker ‚Äì Empacotando a Aplica√ß√£o

1. FROM node:18
Esta linha especifica a imagem base a ser usada para construir a imagem Docker. No caso, est√° sendo usada a imagem oficial do Node.js na vers√£o 18. Essa imagem j√° vem com o Node.js e o npm (Node Package Manager) instalados, o que facilita a configura√ß√£o do ambiente para rodar aplica√ß√µes Node.js.

2. WORKDIR /app
Define o diret√≥rio de trabalho dentro do cont√™iner como /app. Isso significa que, a partir deste ponto, todas as opera√ß√µes de comando (como copiar arquivos ou instalar pacotes) ocorrer√£o dentro desse diret√≥rio. Se o diret√≥rio n√£o existir, ele ser√° criado automaticamente.

3. COPY package*.json ./
Este comando copia os arquivos package.json e package-lock.json (caso existam) da m√°quina local para o diret√≥rio de trabalho do cont√™iner (/app).

O uso do padr√£o package*.json permite copiar tanto o package.json quanto o package-lock.json (que √© gerado automaticamente pelo npm). Esses arquivos cont√™m informa√ß√µes sobre as depend√™ncias da aplica√ß√£o.
4. RUN npm install
Este comando executa o npm install dentro do cont√™iner. Ele instala todas as depend√™ncias listadas no arquivo package.json, garantindo que a aplica√ß√£o tenha tudo o que precisa para rodar. Os pacotes s√£o instalados no diret√≥rio node_modules, que tamb√©m ficar√° dentro do cont√™iner.

5. COPY . .
Este comando copia todos os arquivos e pastas do diret√≥rio atual da m√°quina local para o diret√≥rio de trabalho do cont√™iner (/app). Isso inclui o c√≥digo-fonte da aplica√ß√£o e quaisquer outros arquivos necess√°rios.

Nota: √â importante configurar um arquivo .dockerignore para evitar copiar arquivos desnecess√°rios (como node_modules ou arquivos sens√≠veis) para dentro do cont√™iner.
6. EXPOSE 3000
Este comando informa ao Docker que o cont√™iner ir√° expor a porta 3000. Essa √© a porta onde a aplica√ß√£o estar√° escutando conex√µes (muito comum em aplica√ß√µes Node.js).

Importante: O comando EXPOSE n√£o publica a porta automaticamente no host; ele apenas documenta que essa porta ser√° usada no cont√™iner. Para expor a porta ao host, √© necess√°rio usar a flag -p no comando docker run (ex.: -p 3000:3000).
7. CMD ["npm", "start"]
O comando CMD define o comando padr√£o que ser√° executado quando o cont√™iner for iniciado. Neste caso, ele executa npm start, que normalmente inicia a aplica√ß√£o Node.js.

O script start deve estar definido no arquivo package.json da aplica√ß√£o, geralmente como algo como: "start": "node server.js". Esse script √© respons√°vel por iniciar o servidor da aplica√ß√£o.
Resumo Geral
Este Dockerfile configura um ambiente Docker para uma aplica√ß√£o Node.js, realizando os seguintes passos:

Usa a imagem base do Node.js na vers√£o 18.
Define o diret√≥rio de trabalho como /app.
Copia os arquivos necess√°rios (package.json e package-lock.json) e instala as depend√™ncias.
Copia todo o c√≥digo-fonte da aplica√ß√£o para o cont√™iner.
Exp√µe a porta 3000 para acesso √† aplica√ß√£o.
Configura o comando padr√£o para iniciar a aplica√ß√£o (npm start).
Esse √© um padr√£o comum para criar imagens Docker de aplica√ß√µes Node.js.

3. CI/CD ‚Äì GitHub Actions

name: CI/CD Pipeline on: push: branches: [ main ] jobs: build-and-deploy: runs-on: ubuntu-latest steps: - name: Checkout c√≥digo uses: actions/checkout@v3 - name: Configurar Node.js uses: actions/setup-node@v3 with: node-version: '18' - name: Instalar depend√™ncias run: npm install working-directory: ./app - name: Build Docker image run: docker build -t devops-api ./app - name: Testar rota /health run: | docker run -d -p 3000:3000 --name api devops-api sleep 5 curl -f http://localhost:3000/health docker stop api
O c√≥digo apresentado √© um arquivo de configura√ß√£o para o GitHub Actions, que √© uma ferramenta de integra√ß√£o e entrega cont√≠nua (CI/CD). Ele define um pipeline automatizado que √© executado sempre que houver um push na branch main de um reposit√≥rio. Vamos detalhar cada parte do c√≥digo:

1. Nome do Workflow
Copiar
name: CI/CD Pipeline
Este √© o nome do workflow, chamado "CI/CD Pipeline". Ele ser√° exibido na interface do GitHub Actions.
2. Evento que dispara o workflow
Copiar
on:
  push:
    branches: [ main ]
Este trecho define que o workflow ser√° acionado sempre que houver um push na branch main. Ou seja, qualquer altera√ß√£o enviada para a branch main do reposit√≥rio ir√° disparar a execu√ß√£o do pipeline.
3. Jobs
Copiar
jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
O bloco jobs define as tarefas que ser√£o executadas no pipeline.
O job principal √© chamado build-and-deploy.
A execu√ß√£o do job ser√° feita em um ambiente virtual baseado no sistema operacional Ubuntu (a vers√£o mais recente dispon√≠vel no GitHub Actions: ubuntu-latest).
4. Steps (Etapas do Job)
O job build-and-deploy possui v√°rias etapas (steps) que s√£o executadas em sequ√™ncia. Vamos analisar cada uma delas:

4.1. Checkout do C√≥digo
Copiar
    - name: Checkout c√≥digo
      uses: actions/checkout@v3
Esta etapa utiliza a a√ß√£o oficial actions/checkout na vers√£o v3.
Ela clona o reposit√≥rio (o c√≥digo-fonte) na m√°quina virtual onde o job est√° sendo executado, permitindo que os arquivos sejam utilizados nas etapas seguintes.
4.2. Configurar Node.js
Copiar
    - name: Configurar Node.js
      uses: actions/setup-node@v3
      with:
        node-version: '18'
Esta etapa utiliza a a√ß√£o oficial actions/setup-node na vers√£o v3.
Ela instala e configura o Node.js, especificando a vers√£o 18.
Isso garante que o ambiente esteja preparado para executar comandos relacionados ao Node.js, como a instala√ß√£o de depend√™ncias e execu√ß√£o de scripts.
4.3. Instalar Depend√™ncias
Copiar
    - name: Instalar depend√™ncias
      run: npm install
      working-directory: ./app
Esta etapa instala as depend√™ncias do projeto usando o comando npm install.
O par√¢metro working-directory: ./app indica que o comando ser√° executado dentro da pasta app, presumivelmente onde o c√≥digo do projeto est√° localizado.
4.4. Build da Imagem Docker
Copiar
    - name: Build Docker image
      run: docker build -t devops-api ./app
Aqui, √© feita a constru√ß√£o de uma imagem Docker para o projeto.
O comando docker build cria a imagem Docker utilizando o Dockerfile presente no diret√≥rio ./app.
A flag -t devops-api define o nome/tag da imagem como devops-api.
4.5. Testar a Rota /health
Copiar
    - name: Testar rota /health
      run: |
        docker run -d -p 3000:3000 --name api devops-api
        sleep 5
        curl -f http://localhost:3000/health
        docker stop api
Esta etapa realiza testes b√°sicos para verificar se a aplica√ß√£o est√° funcionando corretamente. Vamos detalhar os comandos:

Executar o container:

Copiar
docker run -d -p 3000:3000 --name api devops-api
Este comando inicia um container baseado na imagem Docker devops-api.
A flag -d executa o container em segundo plano.
A flag -p 3000:3000 mapeia a porta 3000 do container para a porta 3000 da m√°quina host.
O container √© nomeado como api.
Aguardar inicializa√ß√£o:

Copiar
sleep 5
Aguarda 5 segundos para garantir que o container tenha tempo suficiente para inicializar.
Testar a rota /health:

Copiar
curl -f http://localhost:3000/health
Usa o comando curl para fazer uma requisi√ß√£o HTTP para a rota /health, exposta pelo container na porta 3000.
A flag -f faz com que o comando retorne erro caso a resposta HTTP tenha um c√≥digo de status diferente de 2xx.
Parar o container:

Copiar
docker stop api
Ap√≥s realizar o teste, o container √© parado para liberar recursos.
Resumo do Processo
O pipeline √© acionado por um push na branch main.
O c√≥digo do reposit√≥rio √© clonado.
O ambiente Node.js √© configurado com a vers√£o 18.
As depend√™ncias do projeto s√£o instaladas na pasta ./app.
Uma imagem Docker chamada devops-api √© constru√≠da com base no c√≥digo do projeto.
Um container √© criado a partir da imagem, e um teste simples √© realizado para verificar se a rota /health est√° funcionando corretamente.
Ap√≥s o teste, o container √© parado.
Esse pipeline √© √∫til para garantir que o c√≥digo enviado ao reposit√≥rio esteja funcional e pronto para ser implantado em produ√ß√£o ou em outro ambiente.

4. Infraestrutura ‚Äì Terraform na AWS

 se est√° atual) instance_type = "t2.micro" tags = { Name = "DevOpsAPI" } user_data = <<-EOF #!/bin/bash sudo apt update sudo apt install -y docker.io sudo systemctl start docker sudo docker run -d -p 80:3000 ghcr.io/seuusuario/devops-api EOF }
Esse c√≥digo √© um script em Terraform, uma ferramenta de infraestrutura como c√≥digo (IaC), que permite gerenciar recursos de infraestrutura na nuvem de forma declarativa. Abaixo segue uma explica√ß√£o detalhada de cada parte do c√≥digo:

1. Configura√ß√£o do Provider AWS
Copiar
provider "aws" {
  region = "us-east-1"
}
provider "aws": Define que o Terraform usar√° o provedor da AWS para criar e gerenciar os recursos.
region = "us-east-1": Especifica a regi√£o da AWS onde os recursos ser√£o criados. Nesse caso, a regi√£o √© US East (Norte da Virg√≠nia).
2. Defini√ß√£o do Recurso aws_instance
Copiar
resource "aws_instance" "devops_api" {
  ami           = "ami-0c55b159cbfafe1f0" # Ubuntu 22.04 LTS (verifique se est√° atual)
  instance_type = "t2.micro"

  tags = {
    Name = "DevOpsAPI"
  }

  user_data = <<-EOF
              #!/bin/bash
              sudo apt update
              sudo apt install -y docker.io
              sudo systemctl start docker
              sudo docker run -d -p 80:3000 ghcr.io/seuusuario/devops-api
              EOF
}
Essa se√ß√£o define uma inst√¢ncia EC2 na AWS com as seguintes configura√ß√µes:

Atributos principais:
resource "aws_instance" "devops_api":

Cria uma inst√¢ncia EC2 no provedor AWS.
O nome l√≥gico do recurso √© devops_api, usado para referenci√°-lo em outras partes do c√≥digo.
ami = "ami-0c55b159cbfafe1f0":

Define a imagem de m√°quina da Amazon (AMI) que ser√° usada para criar a inst√¢ncia.
Nesse caso, √© utilizada a AMI do Ubuntu 22.04 LTS. O ID pode variar dependendo da regi√£o e do tempo, ent√£o √© importante verificar se est√° atualizado.
instance_type = "t2.micro":

Define o tipo da inst√¢ncia EC2.
O tipo t2.micro √© uma inst√¢ncia de baixo custo, ideal para testes e pequenos workloads, com direito ao n√≠vel gratuito da AWS (Free Tier).
tags:

Adiciona uma tag √† inst√¢ncia EC2.
A tag Name = "DevOpsAPI" ajuda na identifica√ß√£o da inst√¢ncia no console da AWS.
Configura√ß√£o de Inicializa√ß√£o (user_data):
Copiar
user_data = <<-EOF
            #!/bin/bash
            sudo apt update
            sudo apt install -y docker.io
            sudo systemctl start docker
            sudo docker run -d -p 80:3000 ghcr.io/seuusuario/devops-api
            EOF
O bloco user_data cont√©m um script bash que ser√° executado automaticamente durante o processo de inicializa√ß√£o da inst√¢ncia EC2. Esse script configura a inst√¢ncia para rodar um container Docker com uma aplica√ß√£o espec√≠fica.

Passo a passo do script:

sudo apt update:

Atualiza a lista de pacotes dispon√≠veis no sistema operacional.
sudo apt install -y docker.io:

Instala o Docker na inst√¢ncia EC2.
sudo systemctl start docker:

Inicia o servi√ßo Docker.
sudo docker run -d -p 80:3000 ghcr.io/seuusuario/devops-api:

Executa um container Docker em segundo plano (-d) com a aplica√ß√£o hospedada no reposit√≥rio do GitHub Container Registry (ghcr.io/seuusuario/devops-api).
O container exp√µe a porta interna 3000 e a mapeia para a porta 80 da inst√¢ncia EC2, tornando a aplica√ß√£o acess√≠vel via HTTP na porta 80.
Resumo
Este c√≥digo cria uma inst√¢ncia EC2 na AWS (regi√£o us-east-1) com o Ubuntu 22.04 LTS como sistema operacional. Durante a inicializa√ß√£o, a inst√¢ncia instala o Docker, inicia o servi√ßo Docker e executa um container com uma aplica√ß√£o hospedada no GitHub Container Registry. A aplica√ß√£o ser√° acess√≠vel via HTTP na porta 80.

Esse script √© √∫til para automatizar o provisionamento de servidores que rodam aplica√ß√µes baseadas em containers, como parte de um pipeline DevOps ou para projetos simples em nuvem.

/terraform/variables.tf

variable "aws_access_key" {} variable "aws_secret_key" {}
Os c√≥digos apresentados s√£o trechos escritos na linguagem Terraform, que √© uma ferramenta de infraestrutura como c√≥digo (IaC) usada para provisionar e gerenciar recursos em diferentes provedores de nuvem, como AWS, Azure, Google Cloud, entre outros.

Vamos explicar cada parte do c√≥digo:

C√≥digo:
Copiar
variable "aws_access_key" {}
Explica√ß√£o:
Este c√≥digo define uma vari√°vel chamada aws_access_key. Em Terraform, as vari√°veis s√£o usadas para armazenar valores que podem ser reutilizados em diferentes partes do c√≥digo. No caso, aws_access_key provavelmente ser√° usada para armazenar a chave de acesso (Access Key) da AWS, que √© necess√°ria para autenticar e interagir com os servi√ßos da Amazon Web Services.

O bloco {} est√° vazio, o que significa que nenhuma configura√ß√£o adicional foi definida para essa vari√°vel. Por exemplo, n√£o h√° valores padr√£o ou descri√ß√µes associadas √† vari√°vel. O valor dessa vari√°vel ser√° atribu√≠do posteriormente, seja atrav√©s de um arquivo de vari√°veis (.tfvars), da linha de comando ou de outra forma.

C√≥digo:
Copiar
variable "aws_secret_key" {}
Explica√ß√£o:
Este c√≥digo define outra vari√°vel, chamada aws_secret_key. Esta vari√°vel ser√° usada para armazenar a chave secreta (Secret Key) da AWS. A chave secreta √© outro componente necess√°rio para autentica√ß√£o ao usar a AWS.

Assim como no exemplo anterior, o bloco {} est√° vazio, indicando que n√£o h√° configura√ß√µes adicionais para esta vari√°vel.

Contexto geral:
Essas duas vari√°veis (aws_access_key e aws_secret_key) s√£o normalmente usadas para configurar credenciais de acesso √† AWS em um projeto Terraform. Geralmente, elas s√£o referenciadas em outros trechos do c√≥digo Terraform para autentica√ß√£o com o provedor AWS, como no exemplo abaixo:

Copiar
provider "aws" {
  access_key = var.aws_access_key
  secret_key = var.aws_secret_key
  region     = "us-east-1"
}
No exemplo acima:

var.aws_access_key utiliza o valor armazenado na vari√°vel aws_access_key.
var.aws_secret_key utiliza o valor armazenado na vari√°vel aws_secret_key.
Observa√ß√£o importante:
Manter credenciais como aws_access_key e aws_secret_key diretamente no c√≥digo pode ser inseguro. √â recomendado usar pr√°ticas como:

Armazenar essas vari√°veis em arquivos separados (.tfvars) e garantir que eles n√£o sejam versionados no Git (adicionando ao .gitignore).
Utilizar ferramentas de gerenciamento de segredos, como AWS Secrets Manager.
Configurar credenciais utilizando perfis locais (~/.aws/credentials) ao inv√©s de expor diretamente no c√≥digo.
Essas boas pr√°ticas ajudam a proteger informa√ß√µes sens√≠veis e evitar comprometimentos de seguran√ßa.

5. Monitoramento ‚Äì Prometheus + Grafana

Este c√≥digo √© uma configura√ß√£o t√≠pica do Prometheus, que √© uma ferramenta de monitoramento e alerta de c√≥digo aberto. Ele coleta m√©tricas de servi√ßos e as armazena em uma base de dados temporais para an√°lise e consulta. Vamos explicar cada parte do c√≥digo:

1. Bloco global
Copiar
global:
  scrape_interval: 15s
O bloco global cont√©m configura√ß√µes globais que ser√£o aplicadas a todas as tarefas de coleta de m√©tricas configuradas no Prometheus.
A chave scrape_interval define o intervalo de tempo entre as coletas de m√©tricas. Neste caso, o Prometheus ir√° buscar (ou "raspar") as m√©tricas a cada 15 segundos.
2. Bloco scrape_configs
Copiar
scrape_configs:
  - job_name: 'devops-api'
    static_configs:
      - targets: ['localhost:3000']
O bloco scrape_configs define as configura√ß√µes para as tarefas de coleta de m√©tricas. Cada tarefa √© chamada de job.
Aqui, est√° sendo definido um job chamado devops-api (nome arbitr√°rio, que serve para identificar o servi√ßo que est√° sendo monitorado).
Detalhamento:
job_name:

Nome do job (tarefa). Neste caso, o nome √© devops-api.
Este nome √© √∫til para categorizar as m√©tricas coletadas e identific√°-las posteriormente.
static_configs:

Define as configura√ß√µes est√°ticas para os endpoints (endere√ßos) que o Prometheus deve monitorar.
Cada endpoint ou servi√ßo que ser√° monitorado √© especificado na lista targets.
targets:

Lista de endpoints (endere√ßos) onde o Prometheus buscar√° as m√©tricas.
No exemplo, o Prometheus ir√° buscar m√©tricas no endere√ßo localhost:3000, ou seja, no servidor local na porta 3000.
Este endere√ßo normalmente corresponde a um endpoint que exp√µe m√©tricas no formato esperado pelo Prometheus (como /metrics).
Explica√ß√£o Geral
Este arquivo de configura√ß√£o indica que o Prometheus ir√°:

Coletar m√©tricas a cada 15 segundos (scrape_interval: 15s).
Monitorar um servi√ßo chamado devops-api.
Buscar as m√©tricas no endere√ßo localhost:3000.
O servi√ßo que est√° rodando em localhost:3000 precisa estar configurado para expor m√©tricas no formato esperado pelo Prometheus (geralmente no endpoint /metrics). Essas m√©tricas podem incluir informa√ß√µes como uso de CPU, mem√≥ria, n√∫mero de requisi√ß√µes, etc., dependendo do que o servi√ßo est√° expondo.

Se voc√™ precisar integrar isso com um servi√ßo espec√≠fico, como uma API ou aplica√ß√£o, certifique-se de que ela esteja configurada corretamente para expor essas m√©tricas no endpoint correto. Ferramentas como o Prometheus Client Libraries podem ajudar a implementar isso em v√°rias linguagens de programa√ß√£o.

5.1 /monitoring/docker-compose.yml

rafana: image: grafana/grafana ports: - "3001:3000"
O c√≥digo mostrado √© um arquivo docker-compose.yml, utilizado pelo Docker Compose para definir e gerenciar m√∫ltiplos servi√ßos em cont√™ineres. Ele utiliza a vers√£o 3 do formato do Docker Compose. Abaixo est√° uma explica√ß√£o detalhada de cada parte do c√≥digo:

Estrutura Geral
Copiar
version: '3'
version: '3': Define a vers√£o do formato do arquivo docker-compose.yml. A vers√£o 3 √© uma das mais usadas e suporta diversas funcionalidades modernas do Docker Compose.
Copiar
services:
services: Define os servi√ßos que ser√£o executados em cont√™ineres. Cada servi√ßo √© como um aplicativo ou componente que ser√° executado em seu pr√≥prio cont√™iner.
Servi√ßo Prometheus
Copiar
prometheus:
  image: prom/prometheus
  volumes:
    - ./prometheus.yml:/etc/prometheus/prometheus.yml
  ports:
    - "9090:9090"
prometheus: Nome do servi√ßo. Este ser√° o cont√™iner respons√°vel por executar o Prometheus, que √© uma ferramenta de monitoramento e coleta de m√©tricas.

image: prom/prometheus: Especifica a imagem Docker que ser√° usada para criar o cont√™iner. Aqui, est√° sendo utilizada a imagem oficial do Prometheus dispon√≠vel no Docker Hub.

volumes:

Define um volume para mapear arquivos ou diret√≥rios do sistema host para dentro do cont√™iner.
./prometheus.yml:/etc/prometheus/prometheus.yml:
O arquivo prometheus.yml, localizado no diret√≥rio atual do host (indicado por ./), ser√° montado dentro do cont√™iner no caminho /etc/prometheus/prometheus.yml.
Isso permite que o Prometheus dentro do cont√™iner use o arquivo de configura√ß√£o do host para configurar seu comportamento.
ports:

Define o mapeamento de portas entre o host e o cont√™iner.
"9090:9090":
A porta 9090 no host ser√° mapeada para a porta 9090 no cont√™iner.
Isso significa que o Prometheus estar√° acess√≠vel no host na URL http://localhost:9090.
Servi√ßo Grafana
Copiar
grafana:
  image: grafana/grafana
  ports:
    - "3001:3000"
grafana: Nome do servi√ßo. Este ser√° o cont√™iner respons√°vel por executar o Grafana, uma ferramenta de visualiza√ß√£o e an√°lise de m√©tricas.

image: grafana/grafana: Especifica a imagem Docker que ser√° usada para criar o cont√™iner. Aqui, est√° sendo utilizada a imagem oficial do Grafana dispon√≠vel no Docker Hub.

ports:

Define o mapeamento de portas entre o host e o cont√™iner.
"3001:3000":
A porta 3001 no host ser√° mapeada para a porta 3000 no cont√™iner.
Isso significa que o Grafana estar√° acess√≠vel no host na URL http://localhost:3001.
Resumo Geral
O arquivo configura dois servi√ßos:

Prometheus: Uma ferramenta de monitoramento que coleta m√©tricas e as exp√µe na porta 9090.
Grafana: Uma ferramenta de visualiza√ß√£o de m√©tricas que estar√° acess√≠vel na porta 3001.
O Prometheus utiliza um volume para carregar seu arquivo de configura√ß√£o (prometheus.yml) do sistema host.

Esses dois servi√ßos podem ser usados juntos para monitorar sistemas ou aplica√ß√µes, onde o Prometheus coleta as m√©tricas, e o Grafana apresenta essas m√©tricas em um painel visual interativo.

Se voc√™ executar este arquivo com o comando docker-compose up, os dois servi√ßos ser√£o iniciados e estar√£o prontos para uso.

README.md (modelo)

üöÄ Projeto DevOps Vitrine
Este √© um projeto que demonstra um pipeline completo de DevOps. Ele cobre desde a automa√ß√£o de deploys (CI/CD) at√© a infraestrutura como c√≥digo e monitoramento, usando tecnologias modernas.

Tecnologias utilizadas
Node.js + Express:

A aplica√ß√£o principal √© desenvolvida com Node.js, utilizando o framework Express para criar uma API ou servidor web.
Docker:

A aplica√ß√£o √© containerizada, permitindo que seja executada em qualquer ambiente de forma consistente.
GitHub Actions:

√â usado para configurar um pipeline de integra√ß√£o cont√≠nua (CI) e entrega cont√≠nua (CD), automatizando testes, builds e deploys.
Terraform + AWS:

O Terraform √© usado para provisionar a infraestrutura na AWS (Amazon Web Services). Isso significa que os recursos como servidores, bancos de dados, redes, etc., s√£o criados de forma automatizada e declarativa.
Prometheus + Grafana:

Ferramentas de monitoramento:
Prometheus coleta m√©tricas da aplica√ß√£o e da infraestrutura.
Grafana exibe essas m√©tricas em dashboards visuais e f√°ceis de entender.
Funcionalidades do projeto
Deploy autom√°tico via CI/CD:

Quando o c√≥digo √© atualizado no reposit√≥rio (por exemplo, no GitHub), o pipeline configurado no GitHub Actions √© acionado automaticamente para realizar testes, builds e deploys na infraestrutura provisionada.
Infraestrutura provisionada com Terraform:

A infraestrutura necess√°ria para rodar a aplica√ß√£o (m√°quinas virtuais, redes, etc.) √© criada automaticamente com os arquivos de configura√ß√£o do Terraform.
Monitoramento com Prometheus e Grafana:

O estado da aplica√ß√£o e da infraestrutura √© monitorado em tempo real, com m√©tricas como uso de CPU, mem√≥ria, n√∫mero de requisi√ß√µes, etc., sendo exibidas no Grafana.
Como executar localmente
Este projeto pode ser testado localmente de v√°rias formas:

1. Executar a aplica√ß√£o diretamente
Copiar
cd app
npm install
npm start
Navegue at√© o diret√≥rio app, onde est√° o c√≥digo da aplica√ß√£o.
Instale as depend√™ncias do Node.js com npm install.
Inicie a aplica√ß√£o com npm start. A aplica√ß√£o estar√° acess√≠vel em http://localhost:3000.
2. Executar a aplica√ß√£o com Docker
Copiar
docker build -t devops-api .
docker run -p 3000:3000 devops-api
Construa uma imagem Docker da aplica√ß√£o usando docker build. O nome da imagem ser√° devops-api.
Execute o cont√™iner com docker run, mapeando a porta 3000 do cont√™iner para a porta 3000 do host. A aplica√ß√£o estar√° acess√≠vel em http://localhost:3000.
3. Executar o monitoramento
Copiar
cd monitoring
docker-compose up
Navegue at√© o diret√≥rio monitoring, onde est√£o os arquivos de configura√ß√£o do Prometheus e Grafana.
Inicie os servi√ßos de monitoramento usando docker-compose up. Isso ir√° subir cont√™ineres para o Prometheus e o Grafana.
Depois de iniciado:
O Prometheus estar√° dispon√≠vel na porta configurada (geralmente http://localhost:9090).
O Grafana estar√° dispon√≠vel na interface web (geralmente http://localhost:3000 ou outra porta configurada).
Resumo
Este projeto √© um exemplo pr√°tico e completo de um ambiente DevOps moderno. Ele combina:

Desenvolvimento da aplica√ß√£o (Node.js + Express),
Containeriza√ß√£o (Docker),
Automa√ß√£o de deploys (GitHub Actions),
Provisionamento de infraestrutura (Terraform + AWS),
Monitoramento (Prometheus + Grafana).
A execu√ß√£o local permite testar tanto a aplica√ß√£o quanto o monitoramento, facilitando o aprendizado e a implementa√ß√£o em produ√ß√£o.